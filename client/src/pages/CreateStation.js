import { useState, useEffect, useCallback, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import { saveToLocalStorage, getFromLocalStorage } from '../utils/mockData';
import provincesData from '../data/provinces.json';
import chargerTypesData from '../data/chargerTypes.json';
import '../charger-styles.css';

const CreateStation = () => {
  const [formData, setFormData] = useState({
    name: '',
    address: '',
    province: '',
    district: '',
    ward: '',
    contactPhone: '',
    lat: null,
    lng: null,
    chargerTypes: [], // Will store {id, price} objects
    amenities: [],
    operatingHours: { open: '', close: '', is24Hours: false }
  });
  const [overallImages, setOverallImages] = useState([]); // H√¨nh t·ªïng th·ªÉ
  const [chargerImages, setChargerImages] = useState([]); // H√¨nh tr·ª• s·∫°c
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [gettingLocation, setGettingLocation] = useState(false);

  const [dataLoaded, setDataLoaded] = useState(false);
  const [locationDetected, setLocationDetected] = useState(false);
  const [addressSuggestion, setAddressSuggestion] = useState('');
  const [geocodingStatus, setGeocodingStatus] = useState('');
  const [isGeocoding, setIsGeocoding] = useState(false);

  const { user, updateUser } = useAuth();
  const navigate = useNavigate();

  const provinces = useMemo(() => provincesData?.provinces || [], []);
  const chargerTypes = useMemo(() => chargerTypesData?.chargerTypes || [], []);

  useEffect(() => {
    // Ensure data is loaded
    if (provinces.length > 0 && chargerTypes.length > 0) {
      setDataLoaded(true);
    }
  }, [provinces.length, chargerTypes.length]);

  const getCurrentDistricts = () => {
    const selectedProvince = provinces.find(p => p.code === formData.province);
    return selectedProvince ? selectedProvince.districts : [];
  };

  const getCurrentWards = () => {
    const selectedProvince = provinces.find(p => p.code === formData.province);
    if (!selectedProvince) return [];
    const selectedDistrict = selectedProvince.districts.find(d => d.code === formData.district);
    return selectedDistrict?.wards || [];
  };

  // ∆Ø·ªõc t√≠nh t·ªânh d·ª±a tr√™n t·ªça ƒë·ªô (offline fallback)
  const estimateProvinceFromCoords = (lat, lng) => {
    // C√°c v√πng ch√≠nh c·ªßa Vi·ªát Nam
    if (lat >= 21.0 && lat <= 23.5 && lng >= 105.0 && lng <= 106.5) return 'HN'; // H√† N·ªôi
    if (lat >= 10.5 && lat <= 11.0 && lng >= 106.0 && lng <= 107.0) return 'HCM'; // TP.HCM
    if (lat >= 15.8 && lat <= 16.3 && lng >= 107.8 && lng <= 108.5) return 'DN'; // ƒê√† N·∫µng
    if (lat >= 20.7 && lat <= 21.2 && lng >= 106.0 && lng <= 106.8) return 'HP'; // H·∫£i Ph√≤ng
    if (lat >= 10.0 && lat <= 10.5 && lng >= 105.5 && lng <= 106.5) return 'CT'; // C·∫ßn Th∆°
    
    // Mi·ªÅn B·∫Øc
    if (lat >= 20.0) return 'HN';
    // Mi·ªÅn Trung
    if (lat >= 14.0 && lat < 20.0) return 'DN';
    // Mi·ªÅn Nam
    return 'HCM';
  };

  // Reverse geocoding ƒë·ªÉ ƒëo√°n t·ªânh/huy·ªán t·ª´ t·ªça ƒë·ªô v·ªõi retry logic
  const reverseGeocode = useCallback(async (lat, lng, retryCount = 0) => {
    // Tr√°nh g·ªçi tr√πng l·∫∑p
    if (isGeocoding) {
      console.log('üîÑ ƒêang geocoding, b·ªè qua request tr√πng l·∫∑p');
      return;
    }
    
    let controller = null;
    let timeoutId = null;
    
    try {
      setIsGeocoding(true);
      console.log('üîç ƒêang reverse geocoding cho t·ªça ƒë·ªô:', lat, lng);
      setGeocodingStatus(retryCount > 0 ? `ƒêang th·ª≠ l·∫°i... (${retryCount + 1}/3)` : 'ƒêang t√¨m ƒë·ªãa ch·ªâ...');
      
      // T·∫°o AbortController m·ªõi cho m·ªói request
      controller = new AbortController();
      
      // Timeout sau 8 gi√¢y (tƒÉng th·ªùi gian ch·ªù)
      timeoutId = setTimeout(() => {
        if (controller && !controller.signal.aborted) {
          controller.abort();
        }
      }, 8000);
      
      // S·ª≠ d·ª•ng Nominatim API (OpenStreetMap) - mi·ªÖn ph√≠ v·ªõi CORS headers
      const response = await fetch(
        `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1&accept-language=vi`,
        {
          method: 'GET',
          headers: {
            'User-Agent': 'SacVui/1.0'
          },
          signal: controller.signal
        }
      );
      
      // Clear timeout n·∫øu request th√†nh c√¥ng
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      
      console.log('üìç D·ªØ li·ªáu t·ª´ Nominatim API:', data);
      
      if (data && data.address) {
        const address = data.address;
        const fullAddress = data.display_name;
        setAddressSuggestion(fullAddress);
        setGeocodingStatus('');
        
        console.log('üè† Address object:', address);
        
        // Mapping c√°c t√™n th√†nh ph·ªë v·ªõi code - m·ªü r·ªông h∆°n
        const cityMapping = {
          // H·ªì Ch√≠ Minh
          'h·ªì ch√≠ minh': 'HCM',
          'ho chi minh': 'HCM',
          's√†i g√≤n': 'HCM',
          'saigon': 'HCM',
          'th√†nh ph·ªë h·ªì ch√≠ minh': 'HCM',
          'tp h·ªì ch√≠ minh': 'HCM',
          'tp. h·ªì ch√≠ minh': 'HCM',
          
          // H√† N·ªôi
          'h√† n·ªôi': 'HN',
          'ha noi': 'HN',
          'hanoi': 'HN',
          'th√†nh ph·ªë h√† n·ªôi': 'HN',
          'tp h√† n·ªôi': 'HN',
          'tp. h√† n·ªôi': 'HN',
          
          // ƒê√† N·∫µng
          'ƒë√† n·∫µng': 'DN',
          'da nang': 'DN',
          'danang': 'DN',
          'th√†nh ph·ªë ƒë√† n·∫µng': 'DN',
          'tp ƒë√† n·∫µng': 'DN',
          'tp. ƒë√† n·∫µng': 'DN',
          
          // C·∫ßn Th∆°
          'c·∫ßn th∆°': 'CT',
          'can tho': 'CT',
          'cantho': 'CT',
          'th√†nh ph·ªë c·∫ßn th∆°': 'CT',
          'tp c·∫ßn th∆°': 'CT',
          'tp. c·∫ßn th∆°': 'CT',
          
          // H·∫£i Ph√≤ng
          'h·∫£i ph√≤ng': 'HP',
          'hai phong': 'HP',
          'haiphong': 'HP',
          'th√†nh ph·ªë h·∫£i ph√≤ng': 'HP',
          'tp h·∫£i ph√≤ng': 'HP',
          'tp. h·∫£i ph√≤ng': 'HP',
          
          // B√¨nh D∆∞∆°ng
          'b√¨nh d∆∞∆°ng': 'BD',
          'binh duong': 'BD',
          't·ªânh b√¨nh d∆∞∆°ng': 'BD',
          
          // ƒê·ªìng Nai
          'ƒë·ªìng nai': 'DN2',
          'dong nai': 'DN2',
          't·ªânh ƒë·ªìng nai': 'DN2',
          
          // Long An
          'long an': 'LA',
          't·ªânh long an': 'LA'
        };
        
        // L·∫•y th√¥ng tin ƒë·ªãa ch·ªâ t·ª´ nhi·ªÅu tr∆∞·ªùng
        const addressFields = [
          address.city, 
          address.province, 
          address.state,
          address.city_district,
          address.county,
          address.municipality,
          address.administrative_area_level_1,
          address.administrative_area_level_2
        ].filter(Boolean);
        
        console.log('üèôÔ∏è C√°c tr∆∞·ªùng ƒë·ªãa ch·ªâ t√¨m ƒë∆∞·ª£c:', addressFields);
        
        let matchedProvinceCode = null;
        
        // T√¨m t·ªânh ph√π h·ª£p t·ª´ mapping
        for (const cityName of addressFields) {
          const normalizedCity = cityName.toLowerCase()
            .replace(/tp\.|th√†nh ph·ªë|t·ªânh/g, '')
            .replace(/\s+/g, ' ')
            .trim();
          
          console.log('üîç ƒêang ki·ªÉm tra:', normalizedCity);
          
          if (cityMapping[normalizedCity]) {
            matchedProvinceCode = cityMapping[normalizedCity];
            console.log('‚úÖ T√¨m th·∫•y match:', normalizedCity, '->', matchedProvinceCode);
            break;
          }
          
          // Th·ª≠ t√¨m ki·∫øm partial match
          for (const [key, value] of Object.entries(cityMapping)) {
            if (normalizedCity.includes(key) || key.includes(normalizedCity)) {
              matchedProvinceCode = value;
              console.log('‚úÖ T√¨m th·∫•y partial match:', key, '->', value);
              break;
            }
          }
          
          if (matchedProvinceCode) break;
        }
        
        // N·∫øu kh√¥ng t√¨m th·∫•y trong mapping, t√¨m trong danh s√°ch provinces
        if (!matchedProvinceCode) {
          console.log('üîç Kh√¥ng t√¨m th·∫•y trong mapping, th·ª≠ t√¨m trong danh s√°ch provinces...');
          
          for (const cityName of addressFields) {
            const matchedProvince = provinces.find(p => {
              const provinceName = p.name.toLowerCase().replace('tp. ', '').replace('t·ªânh ', '');
              const cityNameLower = cityName.toLowerCase().replace('tp. ', '').replace('t·ªânh ', '');
              
              return provinceName.includes(cityNameLower) || cityNameLower.includes(provinceName);
            });
            
            if (matchedProvince) {
              matchedProvinceCode = matchedProvince.code;
              console.log('‚úÖ T√¨m th·∫•y trong provinces:', matchedProvince.name, '->', matchedProvinceCode);
              break;
            }
          }
        }
        
        // T·∫°o ƒë·ªãa ch·ªâ g·ª£i √Ω
        const suggestedAddress = [
          address.house_number,
          address.road,
          address.suburb || address.neighbourhood || address.quarter
        ].filter(Boolean).join(' ');
        
        console.log('üìç K·∫øt qu·∫£ cu·ªëi c√πng:', {
          province: matchedProvinceCode || 'HCM',
          suggestedAddress
        });
        
        // C·∫≠p nh·∫≠t form data
        setFormData(prev => ({
          ...prev,
          province: matchedProvinceCode || 'HCM',
          address: prev.address || suggestedAddress
        }));
        
        setIsGeocoding(false);
      }
    } catch (error) {
      // Clear timeout n·∫øu c√≥ l·ªói
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      
      setIsGeocoding(false);
      console.error('‚ùå Reverse geocoding error:', error);
      
      // Retry logic - th·ª≠ l·∫°i t·ªëi ƒëa 2 l·∫ßn, nh∆∞ng kh√¥ng retry n·∫øu l√† AbortError li√™n t·ª•c
      if (retryCount < 2 && error.message.includes('Failed to fetch')) {
        console.log(`üîÑ Th·ª≠ l·∫°i l·∫ßn ${retryCount + 1}/2...`);
        setGeocodingStatus(`K·∫øt n·ªëi ch·∫≠m, ƒëang th·ª≠ l·∫°i... (${retryCount + 2}/3)`);
        setTimeout(() => {
          reverseGeocode(lat, lng, retryCount + 1);
        }, 3000); // TƒÉng th·ªùi gian ch·ªù l√™n 3 gi√¢y
        return;
      }
      
      // X·ª≠ l√Ω c√°c lo·∫°i l·ªói kh√°c nhau
      let errorMessage = 'Kh√¥ng th·ªÉ t·ª± ƒë·ªông ƒëo√°n ƒë·ªãa ch·ªâ. Vui l√≤ng nh·∫≠p th·ªß c√¥ng.';
      
      if (error.name === 'AbortError') {
        errorMessage = 'K·∫øt n·ªëi m·∫°ng ch·∫≠m. ƒê√£ th·ª≠ 3 l·∫ßn. Vui l√≤ng nh·∫≠p ƒë·ªãa ch·ªâ th·ªß c√¥ng.';
        console.log('‚è∞ Geocoding timeout sau nhi·ªÅu l·∫ßn th·ª≠');
      } else if (error.message.includes('Failed to fetch')) {
        errorMessage = 'Kh√¥ng c√≥ k·∫øt n·ªëi m·∫°ng. Vui l√≤ng ki·ªÉm tra internet v√† nh·∫≠p ƒë·ªãa ch·ªâ th·ªß c√¥ng.';
        console.log('üåê Kh√¥ng c√≥ k·∫øt n·ªëi m·∫°ng sau nhi·ªÅu l·∫ßn th·ª≠');
      }
      
      // Fallback: ∆∞·ªõc t√≠nh t·ªânh d·ª±a tr√™n t·ªça ƒë·ªô (offline)
      const estimatedProvince = estimateProvinceFromCoords(lat, lng);
      setFormData(prev => ({
        ...prev,
        province: estimatedProvince
      }));
      setAddressSuggestion(`${errorMessage} (∆Ø·ªõc t√≠nh: ${provinces.find(p => p.code === estimatedProvince)?.name || 'TP.HCM'})`);
      setGeocodingStatus('');
    }
  }, [provinces, isGeocoding]);

  // Compress image before upload
  const compressImage = (file, maxWidth = 800, quality = 0.8) => {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = () => {
        // Calculate new dimensions
        const ratio = Math.min(maxWidth / img.width, maxWidth / img.height);
        canvas.width = img.width * ratio;
        canvas.height = img.height * ratio;
        
        // Draw and compress
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        canvas.toBlob(resolve, 'image/jpeg', quality);
      };
      
      img.src = URL.createObjectURL(file);
    });
  };

  const handleImageUpload = async (e, type) => {
    const files = Array.from(e.target.files);
    const compressedImages = [];
    
    for (const file of files) {
      if (file.type.startsWith('image/')) {
        const compressed = await compressImage(file);
        const reader = new FileReader();
        reader.onload = (event) => {
          compressedImages.push({
            id: Date.now() + Math.random(),
            file: compressed,
            preview: event.target.result,
            name: file.name
          });
          
          if (compressedImages.length === files.length) {
            if (type === 'overall') {
              setOverallImages(prev => [...prev, ...compressedImages]);
            } else {
              setChargerImages(prev => [...prev, ...compressedImages]);
            }
          }
        };
        reader.readAsDataURL(compressed);
      }
    }
  };

  const removeImage = (imageId, type) => {
    if (type === 'overall') {
      setOverallImages(prev => prev.filter(img => img.id !== imageId));
    } else {
      setChargerImages(prev => prev.filter(img => img.id !== imageId));
    }
  };

  const getCurrentLocation = useCallback(() => {
    setGettingLocation(true);
    setError('');
    
    if (navigator.geolocation) {
      console.log('üéØ B·∫Øt ƒë·∫ßu l·∫•y v·ªã tr√≠ GPS...');
      
      navigator.geolocation.getCurrentPosition(
        async (position) => {
          try {
            const lat = parseFloat(position.coords.latitude.toFixed(6));
            const lng = parseFloat(position.coords.longitude.toFixed(6));
            const accuracy = position.coords.accuracy;
            
            console.log('üìç T·ªça ƒë·ªô GPS nh·∫≠n ƒë∆∞·ª£c:', {
              lat,
              lng,
              accuracy: `${accuracy}m`,
              timestamp: new Date(position.timestamp).toLocaleString()
            });
            
            setFormData(prev => ({
              ...prev,
              lat,
              lng
            }));
            
            setLocationDetected(true);
            setGettingLocation(false);
            
            // T·ª± ƒë·ªông ƒëo√°n ƒë·ªãa ch·ªâ (c√≥ th·ªÉ b·ªè qua n·∫øu l·ªói)
            console.log('üîç B·∫Øt ƒë·∫ßu reverse geocoding...');
            try {
              await reverseGeocode(lat, lng);
            } catch (geocodeError) {
              console.log('‚ö†Ô∏è B·ªè qua reverse geocoding, user c√≥ th·ªÉ nh·∫≠p th·ªß c√¥ng:', geocodeError);
              // Kh√¥ng l√†m g√¨, ƒë·ªÉ user t·ª± ch·ªçn t·ªânh/huy·ªán
            }
          } catch (positionError) {
            console.error('‚ùå L·ªói x·ª≠ l√Ω v·ªã tr√≠:', positionError);
            setError('L·ªói x·ª≠ l√Ω d·ªØ li·ªáu v·ªã tr√≠. Vui l√≤ng th·ª≠ l·∫°i.');
            setGettingLocation(false);
          }
        },
        (error) => {
          console.error('‚ùå L·ªói l·∫•y v·ªã tr√≠ GPS:', error);
          let errorMessage = 'Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ hi·ªán t·∫°i. ';
          
          switch(error.code) {
            case error.PERMISSION_DENIED:
              errorMessage += 'Vui l√≤ng cho ph√©p truy c·∫≠p v·ªã tr√≠ trong tr√¨nh duy·ªát v√† th·ª≠ l·∫°i.';
              break;
            case error.POSITION_UNAVAILABLE:
              errorMessage += 'Th√¥ng tin v·ªã tr√≠ kh√¥ng kh·∫£ d·ª•ng. H√£y ki·ªÉm tra GPS/WiFi.';
              break;
            case error.TIMEOUT:
              errorMessage += 'H·∫øt th·ªùi gian ch·ªù l·∫•y v·ªã tr√≠. Vui l√≤ng th·ª≠ l·∫°i.';
              break;
            default:
              errorMessage += 'Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c nh·∫≠p th·ªß c√¥ng.';
              break;
          }
          
          setError(errorMessage);
          setGettingLocation(false);
        },
        {
          enableHighAccuracy: true,
          timeout: 20000, // TƒÉng timeout l√™n 20s
          maximumAge: 30000 // Gi·∫£m xu·ªëng 30s ƒë·ªÉ c√≥ d·ªØ li·ªáu m·ªõi h∆°n
        }
      );
    } else {
      setError('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ƒë·ªãnh v·ªã GPS. Vui l√≤ng nh·∫≠p th√¥ng tin th·ªß c√¥ng.');
      setGettingLocation(false);
    }
  }, [reverseGeocode]); // Th√™m reverseGeocode dependency

  // Auto-detect location khi component mount
  useEffect(() => {
    if (dataLoaded && !locationDetected) {
      // T·ª± ƒë·ªông l·∫•y v·ªã tr√≠ khi trang load
      const timer = setTimeout(() => {
        getCurrentLocation();
      }, 500); // Delay nh·ªè ƒë·ªÉ ƒë·∫£m b·∫£o component ƒë√£ render xong
      
      return () => clearTimeout(timer);
    }
  }, [dataLoaded, locationDetected]);

  if (!user) {
    return <div>Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ t·∫°o tr·∫°m s·∫°c</div>;
  }

  if (!dataLoaded) {
    return <div className="loading">ƒêang t·∫£i d·ªØ li·ªáu...</div>;
  }

  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    
    if (name.startsWith('operatingHours.')) {
      const field = name.split('.')[1];
      setFormData({
        ...formData,
        operatingHours: {
          ...formData.operatingHours,
          [field]: type === 'checkbox' ? checked : value
        }
      });
    } else {
      setFormData({ ...formData, [name]: value });
    }
  };

  const handleChargerTypeChange = (chargerId, checked) => {
    if (checked) {
      const chargerType = chargerTypes.find(ct => ct.id === chargerId);
      const newChargerType = {
        id: chargerId,
        name: chargerType.name,
        price: chargerType.defaultPrice
      };
      setFormData({
        ...formData,
        chargerTypes: [...formData.chargerTypes, newChargerType]
      });
    } else {
      setFormData({
        ...formData,
        chargerTypes: formData.chargerTypes.filter(ct => ct.id !== chargerId)
      });
    }
  };

  const handleChargerPriceChange = (chargerId, price) => {
    setFormData({
      ...formData,
      chargerTypes: formData.chargerTypes.map(ct => 
        ct.id === chargerId ? { ...ct, price: parseInt(price) } : ct
      )
    });
  };



  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 1500));

    try {
      // Validate required fields
      if (!formData.name || !formData.address || !formData.province || !formData.district || !formData.contactPhone) {
        throw new Error('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin b·∫Øt bu·ªôc');
      }

      if (!formData.lat || !formData.lng) {
        throw new Error('Vui l√≤ng l·∫•y t·ªça ƒë·ªô GPS ho·∫∑c ch·ªçn v·ªã tr√≠ tr√™n b·∫£n ƒë·ªì');
      }

      if (formData.chargerTypes.length === 0) {
        throw new Error('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt lo·∫°i s·∫°c');
      }



      // T·∫°o station m·ªõi
      const newStation = {
        id: Date.now().toString(),
        name: formData.name,
        address: formData.address,
        province: formData.province,
        district: formData.district,
        ward: formData.ward,
        contactPhone: formData.contactPhone,
        latitude: formData.lat,
        longitude: formData.lng,
        rating: 0,
        totalRatings: 0,
        chargerTypes: formData.chargerTypes.map(ct => ct.name),
        pricing: formData.chargerTypes.map(ct => ({
          chargerType: ct.name,
          pricePerHour: ct.price
        })),
        amenities: formData.amenities,
        images: {
          overall: overallImages.map(img => img.name),
          charger: chargerImages.map(img => img.name)
        },
        isVerified: false,
        status: 'ACTIVE',
        operatingHours: formData.operatingHours,
        promotions: [],
        owner: {
          name: user.name,
          phone: user.phone || 'Ch∆∞a c·∫≠p nh·∫≠t'
        },
        ownerId: user.id,
        createdAt: new Date().toISOString()
      };

      // L∆∞u v√†o localStorage
      const stations = getFromLocalStorage('userStations', []);
      stations.push(newStation);
      saveToLocalStorage('userStations', stations);

      // Th∆∞·ªüng ƒëi·ªÉm cho user
      const updatedUser = { ...user, points: (user.points || 0) + 100 };
      updateUser(updatedUser);

      alert('üéâ T·∫°o tr·∫°m s·∫°c th√†nh c√¥ng! B·∫°n ƒë∆∞·ª£c th∆∞·ªüng 100 ƒëi·ªÉm. Tr·∫°m s·∫°c s·∫Ω ƒë∆∞·ª£c xem x√©t ƒë·ªÉ x√°c minh.');
      navigate('/profile');
    } catch (error) {
      setError(error.message || 'C√≥ l·ªói x·∫£y ra');
    }
    
    setLoading(false);
  };

  return (
    <div style={{ 
      padding: '1rem', 
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #1f2937, #111827)',
      color: 'white'
    }}>
      {/* Back Button */}
      <div style={{ marginBottom: '1rem' }}>
        <button 
          onClick={() => navigate(-1)}
          className="back-button"
        >
          ‚Üê Quay l·∫°i
        </button>
      </div>
      
      <div className="form-container" style={{ maxWidth: '800px' }}>
        <h2>‚ö° Th√™m tr·∫°m s·∫°c m·ªõi</h2>
        {error && <div className="error-message">{error}</div>}
        
        {/* GPS Location Section */}
        <div className="location-section" style={{ 
          background: locationDetected ? 'rgba(34, 197, 94, 0.15)' : 'rgba(59, 130, 246, 0.15)', 
          border: `1px solid ${locationDetected ? 'rgba(34, 197, 94, 0.4)' : 'rgba(59, 130, 246, 0.4)'}`,
          borderRadius: '12px', 
          padding: '1rem', 
          marginBottom: '1.5rem' 
        }}>
          <h3 style={{ margin: '0 0 1rem 0', color: locationDetected ? '#10b981' : '#60a5fa' }}>
            üìç B∆∞·ªõc 1: X√°c ƒë·ªãnh v·ªã tr√≠ tr·∫°m s·∫°c
          </h3>
          
          {!locationDetected ? (
            <div>
              <p style={{ margin: '0 0 1rem 0', fontSize: '0.9rem', color: '#6b7280' }}>
                Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ t·ª± ƒë·ªông l·∫•y t·ªça ƒë·ªô GPS v√† ƒëo√°n ƒë·ªãa ch·ªâ
              </p>
              
              {error && (
                <div style={{ 
                  background: 'rgba(239, 68, 68, 0.1)', 
                  border: '1px solid rgba(239, 68, 68, 0.3)',
                  borderRadius: '8px',
                  padding: '0.75rem',
                  marginBottom: '1rem',
                  color: '#fca5a5'
                }}>
                  <div style={{ fontWeight: '600', marginBottom: '0.5rem' }}>‚ùå L·ªói l·∫•y v·ªã tr√≠:</div>
                  <div style={{ fontSize: '0.9rem' }}>{error}</div>
                </div>
              )}
              
              <div style={{ display: 'flex', gap: '0.75rem', flexWrap: 'wrap' }}>
                <button 
                  type="button"
                  onClick={getCurrentLocation}
                  disabled={gettingLocation}
                  className="location-btn"
                  style={{
                    background: gettingLocation ? 'rgba(59, 130, 246, 0.5)' : 'linear-gradient(135deg, #3b82f6, #1d4ed8)',
                    color: 'white',
                    border: 'none',
                    padding: '0.75rem 1.5rem',
                    borderRadius: '8px',
                    fontSize: '1rem',
                    fontWeight: '600',
                    cursor: gettingLocation ? 'not-allowed' : 'pointer',
                    opacity: gettingLocation ? 0.7 : 1,
                    transition: 'all 0.2s ease'
                  }}
                >
                  {gettingLocation ? 'üîÑ ƒêang l·∫•y v·ªã tr√≠...' : 'üéØ L·∫•y v·ªã tr√≠ hi·ªán t·∫°i'}
                </button>
                
                <button 
                  type="button"
                  onClick={() => {
                    setLocationDetected(true);
                    setFormData(prev => ({ ...prev, lat: 10.7769, lng: 106.7009, province: 'HCM' }));
                    setError('');
                  }}
                  className="manual-location-btn"
                  style={{
                    background: 'rgba(255, 255, 255, 0.1)',
                    color: 'rgba(255, 255, 255, 0.8)',
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                    padding: '0.75rem 1.5rem',
                    borderRadius: '8px',
                    fontSize: '1rem',
                    fontWeight: '600',
                    cursor: 'pointer',
                    transition: 'all 0.2s ease'
                  }}
                  onMouseOver={(e) => {
                    e.target.style.background = 'rgba(255, 255, 255, 0.2)';
                    e.target.style.color = '#ffffff';
                  }}
                  onMouseOut={(e) => {
                    e.target.style.background = 'rgba(255, 255, 255, 0.1)';
                    e.target.style.color = 'rgba(255, 255, 255, 0.8)';
                  }}
                >
                  üìù Nh·∫≠p th·ªß c√¥ng
                </button>
              </div>
              
              <div style={{ 
                marginTop: '1rem', 
                padding: '0.75rem', 
                background: 'rgba(59, 130, 246, 0.1)',
                borderRadius: '8px',
                fontSize: '0.85rem',
                color: 'rgba(255, 255, 255, 0.7)'
              }}>
                üí° <strong>M·∫πo:</strong> ƒê·ªÉ l·∫•y v·ªã tr√≠ ch√≠nh x√°c, h√£y ƒë·∫£m b·∫£o:
                <ul style={{ margin: '0.5rem 0 0 1rem', paddingLeft: '1rem' }}>
                  <li>Cho ph√©p truy c·∫≠p v·ªã tr√≠ trong tr√¨nh duy·ªát</li>
                  <li>B·∫≠t GPS/Location Services tr√™n thi·∫øt b·ªã</li>
                  <li>K·∫øt n·ªëi WiFi ho·∫∑c d·ªØ li·ªáu di ƒë·ªông ·ªïn ƒë·ªãnh</li>
                </ul>
              </div>
            </div>
          ) : (
            <div className="location-success">
              <div className="location-info">
                <span style={{ color: '#059669', fontSize: '1.2rem' }}>‚úÖ</span>
                <span style={{ fontWeight: '600', color: '#059669' }}>ƒê√£ l·∫•y t·ªça ƒë·ªô GPS th√†nh c√¥ng!</span>
              </div>
              
              <div className="location-coords">
                üìç T·ªça ƒë·ªô: {formData.lat}, {formData.lng}
              </div>
              
              {geocodingStatus && (
                <div className="location-address" style={{ color: '#f59e0b' }}>
                  üîÑ {geocodingStatus}
                </div>
              )}
              
              {addressSuggestion && (
                <div className="location-address">
                  üè† ƒê·ªãa ch·ªâ g·ª£i √Ω: {addressSuggestion}
                </div>
              )}
              
              <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                <button 
                  type="button"
                  onClick={() => {
                    setLocationDetected(false);
                    setFormData(prev => ({ ...prev, lat: null, lng: null, province: '', district: '', ward: '' }));
                    setAddressSuggestion('');
                    setGeocodingStatus('');
                  }}
                  className="retry-location-btn"
                >
                  üîÑ L·∫•y l·∫°i v·ªã tr√≠
                </button>
                
                <button 
                  type="button"
                  onClick={() => {
                    const url = `https://www.google.com/maps?q=${formData.lat},${formData.lng}`;
                    window.open(url, '_blank');
                  }}
                  className="retry-location-btn"
                  style={{ background: 'rgba(59, 130, 246, 0.2)', borderColor: 'rgba(59, 130, 246, 0.4)', color: '#60a5fa' }}
                >
                  üó∫Ô∏è Xem tr√™n b·∫£n ƒë·ªì
                </button>
              </div>
            </div>
          )}
        </div>
      
      <form onSubmit={handleSubmit}>
        {/* Hi·ªÉn th·ªã form khi ƒë√£ c√≥ t·ªça ƒë·ªô GPS ho·∫∑c user ch·ªçn nh·∫≠p th·ªß c√¥ng */}
        {(locationDetected || formData.lat !== null) && (
          <>
            {/* ƒê·ªãa ch·ªâ - B∆∞·ªõc 2 */}
            <div className="form-section">
              <h3 className="section-title">üìç B∆∞·ªõc 2: X√°c nh·∫≠n ƒë·ªãa ch·ªâ tr·∫°m s·∫°c</h3>
              
              <div className="form-row">
                <div className="form-group">
                  <label>üèôÔ∏è T·ªânh/Th√†nh ph·ªë * <span className="auto-detected">(ƒë√£ t·ª± ƒë·ªông ƒëo√°n)</span></label>
                  <select
                    name="province"
                    value={formData.province}
                    onChange={handleChange}
                    required
                  >
                    <option value="">Ch·ªçn t·ªânh/th√†nh ph·ªë</option>
                    {provinces.map(province => (
                      <option key={province.code} value={province.code}>
                        {province.name}
                      </option>
                    ))}
                  </select>
                </div>

                {formData.province && (
                  <div className="form-group">
                    <label>üèòÔ∏è Qu·∫≠n/Huy·ªán *</label>
                    <select
                      name="district"
                      value={formData.district}
                      onChange={handleChange}
                      required
                    >
                      <option value="">Ch·ªçn qu·∫≠n/huy·ªán</option>
                      {getCurrentDistricts().map(district => (
                        <option key={district.code} value={district.code}>
                          {district.name}
                        </option>
                      ))}
                    </select>
                  </div>
                )}
              </div>

              {formData.district && getCurrentWards().length > 0 && (
                <div className="form-group">
                  <label>üè† Ph∆∞·ªùng/X√£</label>
                  <select
                    name="ward"
                    value={formData.ward}
                    onChange={handleChange}
                  >
                    <option value="">Ch·ªçn ph∆∞·ªùng/x√£ (t√πy ch·ªçn)</option>
                    {getCurrentWards().map(ward => (
                      <option key={ward.code} value={ward.code}>
                        {ward.name}
                      </option>
                    ))}
                  </select>
                </div>
              )}

              <div className="form-group">
                <label>üè¢ ƒê·ªãa ch·ªâ c·ª• th·ªÉ *</label>
                <input
                  type="text"
                  name="address"
                  value={formData.address}
                  onChange={handleChange}
                  placeholder="VD: 123 Nguy·ªÖn Hu·ªá, Ph∆∞·ªùng B·∫øn Ngh√©"
                  required
                />
                {addressSuggestion && !formData.address && (
                  <button 
                    type="button"
                    onClick={() => setFormData(prev => ({ ...prev, address: addressSuggestion }))}
                    className="address-suggestion-btn"
                  >
                    üí° S·ª≠ d·ª•ng g·ª£i √Ω: {addressSuggestion}
                  </button>
                )}
              </div>
            </div>

            {/* Th√¥ng tin c∆° b·∫£n - B∆∞·ªõc 3 */}
            {formData.province && formData.district && (
              <div className="form-section">
                <h3 className="section-title">üìù B∆∞·ªõc 3: Th√¥ng tin tr·∫°m s·∫°c</h3>
                
                <div className="form-group">
                  <label>‚ö° T√™n tr·∫°m s·∫°c *</label>
                  <input
                    type="text"
                    name="name"
                    value={formData.name}
                    onChange={handleChange}
                    placeholder="VD: Tr·∫°m s·∫°c Vincom Qu·∫≠n 1"
                    required
                  />
                </div>
                
                <div className="form-group">
                  <label>üìû S·ªë ƒëi·ªán tho·∫°i li√™n h·ªá *</label>
                  <input
                    type="tel"
                    name="contactPhone"
                    value={formData.contactPhone}
                    onChange={handleChange}
                    placeholder="VD: 0901234567"
                    required
                  />
                  <p className="field-hint">
                    S·ªë ƒëi·ªán tho·∫°i ƒë·ªÉ kh√°ch h√†ng li√™n h·ªá khi c√≥ v·∫•n ƒë·ªÅ v·ªõi tr·∫°m s·∫°c
                  </p>
                </div>
              </div>
            )}
          </>
        )}

        {/* Th√¥ng b√°o c·∫ßn l·∫•y GPS tr∆∞·ªõc */}
        {!locationDetected && (
          <div className="form-section" style={{ textAlign: 'center', padding: '3rem 2rem' }}>
            <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>üìç</div>
            <h3 style={{ color: '#60a5fa', marginBottom: '1rem' }}>Vui l√≤ng l·∫•y t·ªça ƒë·ªô GPS tr∆∞·ªõc</h3>
            <p style={{ color: '#9ca3af', fontSize: '1rem', lineHeight: '1.6' }}>
              ƒê·ªÉ t·∫°o tr·∫°m s·∫°c, b·∫°n c·∫ßn l·∫•y t·ªça ƒë·ªô GPS ch√≠nh x√°c c·ªßa v·ªã tr√≠ tr·∫°m s·∫°c.<br/>
              Nh·∫•n n√∫t "üéØ L·∫•y v·ªã tr√≠ hi·ªán t·∫°i" ·ªü ph√≠a tr√™n ƒë·ªÉ ti·∫øp t·ª•c.
            </p>
          </div>
        )}
        

        {/* Lo·∫°i s·∫°c v√† gi√° c·∫£ */}
        <div className="form-section charger-types-section">
          <h3 className="section-title">üîå Lo·∫°i s·∫°c v√† gi√° c·∫£</h3>
          <div className="field-hint">
            <strong>üí° H∆∞·ªõng d·∫´n:</strong> Ch·ªçn c√°c lo·∫°i s·∫°c c√≥ t·∫°i tr·∫°m c·ªßa b·∫°n v√† thi·∫øt l·∫≠p m·ª©c gi√° c·∫°nh tranh. 
            Gi√° c·∫£ h·ª£p l√Ω s·∫Ω thu h√∫t nhi·ªÅu kh√°ch h√†ng h∆°n v√† tƒÉng doanh thu.
          </div>
          
          {formData.chargerTypes.length > 0 && (
            <div className="charger-selection-counter">
              ‚úÖ ƒê√£ ch·ªçn {formData.chargerTypes.length} lo·∫°i s·∫°c
            </div>
          )}
          
          <div className="charger-types-grid">
            {chargerTypes.map((charger) => {
              const isSelected = formData.chargerTypes.some(ct => ct.id === charger.id);
              const selectedCharger = formData.chargerTypes.find(ct => ct.id === charger.id);
              
              return (
                <div key={charger.id} className={`charger-type-card ${isSelected ? 'selected' : ''}`}>
                  <div className="charger-power-badge">{charger.power}</div>
                  <label className="charger-header">
                    <input
                      type="checkbox"
                      checked={isSelected}
                      onChange={(e) => handleChargerTypeChange(charger.id, e.target.checked)}
                      className="charger-checkbox"
                    />
                    <div className="charger-icon">{charger.icon}</div>
                    <div className="charger-info">
                      <div className="charger-name">{charger.name}</div>
                      <div className="charger-desc">{charger.description}</div>
                      <div className="charger-time">‚è±Ô∏è {charger.chargingTime}</div>
                      <div className="vehicle-indicators">
                        {charger.vehicleTypes.map(vehicle => (
                          <span key={vehicle} className="vehicle-indicator">
                            {vehicle === 'car' ? 'üöó √î t√¥' : 'üèçÔ∏è Xe m√°y'}
                          </span>
                        ))}
                      </div>
                    </div>
                    <div className="check-indicator">‚úì</div>
                  </label>
                  
                  {isSelected && (
                    <div className="charger-price-section">
                      <label className="price-label">
                        üí∞ Gi√° (VNƒê/gi·ªù):
                        <span className="recommended-price">
                          üí° ƒê·ªÅ xu·∫•t: {charger.defaultPrice.toLocaleString()}ƒë
                        </span>
                      </label>
                      <div className="price-input-group">
                        <div className="price-input-container">
                          <input
                            type="number"
                            value={selectedCharger?.price || charger.defaultPrice}
                            onChange={(e) => handleChargerPriceChange(charger.id, e.target.value)}
                            min={charger.priceRange.min}
                            max={charger.priceRange.max}
                            className="price-input"
                            placeholder={charger.defaultPrice.toString()}
                          />
                        </div>
                        <span className="price-range">
                          Kho·∫£ng gi√° th·ªã tr∆∞·ªùng: {charger.priceRange.min.toLocaleString()}ƒë - {charger.priceRange.max.toLocaleString()}ƒë
                        </span>
                      </div>
                    </div>
                  )}
                </div>
              );
            })}
          </div>
          
          {/* Pricing Summary */}
          {formData.chargerTypes.length > 0 && (
            <div className="pricing-summary">
              <h4 className="pricing-summary-title">
                üí∞ T√≥m t·∫Øt gi√° c·∫£ ({formData.chargerTypes.length} lo·∫°i s·∫°c)
              </h4>
              <div className="pricing-summary-list">
                {formData.chargerTypes.map((chargerType) => {
                  const charger = chargerTypes.find(ct => ct.id === chargerType.id);
                  return (
                    <div key={chargerType.id} className="pricing-summary-item">
                      <span className="pricing-summary-charger">
                        {charger?.icon} {charger?.name}
                      </span>
                      <span className="pricing-summary-price">
                        {parseInt(chargerType.price || charger?.defaultPrice || 0).toLocaleString('vi-VN')}ƒë/gi·ªù
                      </span>
                    </div>
                  );
                })}
              </div>
            </div>
          )}
          
          {/* Revenue Estimate */}
          {formData.chargerTypes.length > 0 && (
            <div className="revenue-estimate">
              <h4 className="revenue-estimate-title">
                üìä ∆Ø·ªõc t√≠nh doanh thu
              </h4>
              <div className="revenue-estimate-text">
                V·ªõi {formData.chargerTypes.length} lo·∫°i s·∫°c v√† gi√° trung b√¨nh{' '}
                {Math.round(
                  formData.chargerTypes.reduce((sum, ct) => {
                    const charger = chargerTypes.find(c => c.id === ct.id);
                    return sum + parseInt(ct.price || charger?.defaultPrice || 0);
                  }, 0) / formData.chargerTypes.length
                ).toLocaleString()}ƒë/gi·ªù, 
                b·∫°n c√≥ th·ªÉ thu v·ªÅ <strong>
                  {(Math.round(
                    formData.chargerTypes.reduce((sum, ct) => {
                      const charger = chargerTypes.find(c => c.id === ct.id);
                      return sum + parseInt(ct.price || charger?.defaultPrice || 0);
                    }, 0) / formData.chargerTypes.length
                  ) * 8 * 30).toLocaleString()}ƒë - {(Math.round(
                    formData.chargerTypes.reduce((sum, ct) => {
                      const charger = chargerTypes.find(c => c.id === ct.id);
                      return sum + parseInt(ct.price || charger?.defaultPrice || 0);
                    }, 0) / formData.chargerTypes.length
                  ) * 12 * 30).toLocaleString()}ƒë/th√°ng
                </strong> (∆∞·ªõc t√≠nh 8-12 gi·ªù s·ª≠ d·ª•ng/ng√†y).
              </div>
            </div>
          )}
        </div>

        {/* H√¨nh ·∫£nh tr·∫°m s·∫°c */}
        <div className="form-section">
          <h3 className="section-title">üì∏ H√¨nh ·∫£nh tr·∫°m s·∫°c</h3>
          
          <div className="image-upload-row">
            {/* H√¨nh ·∫£nh t·ªïng th·ªÉ */}
            <div className="image-upload-group">
              <label className="image-group-label">üè¢ H√¨nh ·∫£nh t·ªïng th·ªÉ (t·ªëi ƒëa 3)</label>
              <div className="image-upload-section">
                <input
                  type="file"
                  multiple
                  accept="image/*"
                  onChange={(e) => handleImageUpload(e, 'overall')}
                  className="image-input"
                  id="overall-images"
                />
                <label htmlFor="overall-images" className="image-upload-btn-small">
                  üì∑ Ch·ªçn h√¨nh
                </label>
                <p className="image-tip">H√¨nh ·∫£nh to√†n c·∫£nh tr·∫°m s·∫°c, b√£i ƒë·ªó xe, khu v·ª±c xung quanh</p>
                
                {overallImages.length > 0 && (
                  <div className="image-preview-grid">
                    {overallImages.map((image) => (
                      <div key={image.id} className="image-preview-item">
                        <img src={image.preview} alt="Preview" />
                        <button 
                          type="button"
                          onClick={() => removeImage(image.id, 'overall')}
                          className="remove-image-btn"
                        >
                          ‚úï
                        </button>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>

            {/* H√¨nh ·∫£nh tr·ª• s·∫°c */}
            <div className="image-upload-group">
              <label className="image-group-label">üîå H√¨nh ·∫£nh tr·ª• s·∫°c (t·ªëi ƒëa 3)</label>
              <div className="image-upload-section">
                <input
                  type="file"
                  multiple
                  accept="image/*"
                  onChange={(e) => handleImageUpload(e, 'charger')}
                  className="image-input"
                  id="charger-images"
                />
                <label htmlFor="charger-images" className="image-upload-btn-small">
                  üì∑ Ch·ªçn h√¨nh
                </label>
                <p className="image-tip">H√¨nh ·∫£nh chi ti·∫øt c√°c tr·ª• s·∫°c, c·ªïng s·∫°c, b·∫£ng gi√°</p>
                
                {chargerImages.length > 0 && (
                  <div className="image-preview-grid">
                    {chargerImages.map((image) => (
                      <div key={image.id} className="image-preview-item">
                        <img src={image.preview} alt="Preview" />
                        <button 
                          type="button"
                          onClick={() => removeImage(image.id, 'charger')}
                          className="remove-image-btn"
                        >
                          ‚úï
                        </button>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
        
        <button type="submit" className="btn-primary" disabled={loading} style={{ width: '100%', marginTop: '1rem' }}>
          {loading ? '‚è≥ ƒêang t·∫°o tr·∫°m s·∫°c...' : 'üöÄ T·∫°o tr·∫°m s·∫°c (+100 ƒëi·ªÉm)'}
        </button>
        
        <div className="success-message">
          <p>
            üéÅ T·∫°o tr·∫°m s·∫°c th√†nh c√¥ng s·∫Ω ƒë∆∞·ª£c th∆∞·ªüng 100 ƒëi·ªÉm!<br/>
            ‚úÖ Sau khi ƒë∆∞·ª£c admin x√°c minh s·∫Ω th∆∞·ªüng th√™m 200 ƒëi·ªÉm n·ªØa!
          </p>
        </div>
      </form>
      </div>
    </div>
  );
};

export default CreateStation;